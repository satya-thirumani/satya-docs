Octave								http://satya-data.blogspot.com

An interpreted programming language.
Octave is one of alternatives to Matlab, FreeMat and Scilab.
The program is named after Octave Levenspiel, a former professor of the principal author.

help plot

+			% addition
-			% subtraction
*			% multiplication
/			% division
^			% exponentiation
== 			% equality
~=			% not equality
&&			% logical AND
&			%
||			% logical OR
|			%
xor(1,0)

%			% commenting character
;			% will suppress output

PS1('>> ');	% octave prompt
PS1('octave>> ');

exp (i*pi)

format short
format long

s = 2		% Initialize constant s 
a =1, b=2, c=3
x=1; y=5; z=9;
text = "Hello world"
x.a = 1; x.b = [1, 2; 3, 4]; x.c = "string";
x.b
x

who
whos

clc			% command line clear (or) clear console
clear			% clears all variables
pwd
cd 
ls
dir

disp(var)
disp(sprintf('4 decimals: %0.4f', var)
disp("x is positive")
sprintf("pi to 8 decimal points: %0.8f", pi)
sprintf('yes')

roots([1, -5])		% used for solving algebraic equations
s = roots(v);
disp('Numeric value of fourth root'), disp(double(s(4)));


Control statements
if x>5,
	disp("x is larger than 5");
end;

if v(1)==1,
	disp('it is one');
elseif v(1)==2,
	disp('it is two');
else
	disp('it is more than two');
end;

Loops
for i=1:10,
	disp(i)
end;

while i <=8,
	v(i) =100;
	i = i+1;
end;

break;
continue;

Functions
addpath('c:\users\satya\Desktop')

vi function.m
function y=squareNumber(x)
	y=x^2;
endfunction

function [y1,y2]=squareAndCubeNumber(x)
	y1=x^2;
	y2=x^3;
endfunction

prediction=0.0;
for j=1:n+1,
	prediction = prediction + theta(j) * x(j)
end;

nargin()
usage("func(argument)")
usage("mini(vector)")

exception handling
unwind_protect
   body
unwind_protect_cleanup
   cleanup
end_unwind_protect

try
   body
catch
   exception_handling
end

error("error message")


Matrices
A = [1 2; 3 4; 5 6]
A = [ 1, 1, 2; 3, 5, 8; 13, 21, 34 ]
A = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12]		% The ; denotes we are going back to a new row.
B = rand (3, 2);
s=1:6
2:3:15

2 * A
A * B			% matrix multiplication
A .* C			% element wise multiplication
A .^ 2			% element wise squaring
1 ./ A
A'				% A transpose
A' * A
(A')'
max(A)
max(A, [], 1)		% column-wise max value
max(A, [], 2)		% row-wise max value
max(max(A))
max(A(:))
[r, c] = find(A > 9)
sum(A, 1)			% sums up all columns, default
sum(A, 2)			% sums up all rows
sum(sum(A .* eye(8)))
sum(sum(A .* flipud(eye(8))))
prediction = theta' * x;

row_vect = [1 5 8]
v=1:6
row_vector = 1:0.1:2
col_vect = [3; 6; 9]
v = mat(1:10)
v = [1;2;3] 		% Initialize a vector 
2 ./ v
-v				% -1 * v
v .* v
isvector(x)
log(v)
abs(v)
exp(v)
prod(a)
v + ones(length(v), 1)
sum(a)
prod(a)
max(v)
[val,ind] = max(a)
a < 6
find(a > 4)
floor(a)
ceil(a)
round(x)
inv(M)			% inverses of matrix
pinv(A)			% inverses of matrices in octave with the pinv(A) function
M^-1			% inverses of matrix
M\eye(size(M))		% inverses of matrix
flipud(A)

ones(2,3)
ones(4)
C = 2 * ones(3,4)
w = zeros(3)
I = eye(2)			% Initialize a 2 by 2 identity matrix, is the same as I = [1,0;0,1]
eye(5,5)
flipud(eye(9))
rand(3,3)
randn(1,3)
help rand
A = magic(3)

Indexing starts at 1, in Octave
A(2,3)
B(2,:)			% means all elements
C(:,2)
A([1 3], :)
S(3, [1,2])
S(2, [1:3])
B(:)
A(:,3) = [10; 14; 18]
B = [B, [22; 33; 44]];
C = [A B]			% concatenating matrices
C = [A; B]			% appending matrices

size(A)			% dimension of matrix, #rows & # cols
size(A,1)			% of rows
size(A,2)			% of cols
length(v)
length([1;2;5;7;9])

[m,n] = size(A)			% Get the dimension of the matrix A where m = rows and n = columns
dim_A = size(A)		% You could also store it this way
dim_v = size(v)		% Get the dimension of the vector v 	
A_23 = A(2,3)			% Now let's index into the 2nd row 3rd column of matrix A

add_AB = A + B 		% See how element-wise addition works
sub_AB = A - B		% See how element-wise subtraction works
mult_As = A * s		% See how scalar multiplication works
div_As = A / s			% Divide A by s
add_As = A + s		% What happens if we have a Matrix + scalar?

IA = I*A 				% What happens when we multiply I*A ?
AI = A*I 				% How about A*I ? 
AB = A*B 			% Compute A*B
BA = B*A 			% Is it equal to B*A?
% Note that IA = AI but AB != BA

Plots:
plot (t, x)
t = [0:0.01:2]
plot(t, sin(2*pi*4*t)
hold on;
plot(t, y2, 'r');
xlabel('time')
ylabel('value')
legend('sin','cos')
title('my plot')
print -dpng 'plot.png'
print -djpg 'plot.jpg'
close
figure(1)
figure(2); plot(x, y2)
subplot(1,2,1);
axis([0.5 1 -1 1])
axis([1 5 1 8])
clf			% clear figure
imagesc(A)
imagesc(magic(15))
imagesc(A), colorbar, colormap gray;

hist(x [,y])
hist(a)
hist(x, 20)
scatter(x,y,s)
contour(x,y,z)
contour(var)

t = linspace (0, 50, 200)';
y = linspace (0.1, 0.2, 50)';
polar(theta, rho)
polar(x,y)
pie(x, explode)
pie(y)
[x,y] = meshgrid(x,y)
mesh(x,y,z)	– Draws a wireframe mesh.
meshc(x,y,z) 	– Draws a wireframe mesh with underlying contour lines.
meshz(x,y,z) 	– Draws a wireframe mesh with Z curtain.
surf(x,y,z) 	– Draws a shaded mesh.

linestyles(‘-’ ‘--’ ‘:’  ‘-.’)
markerstyles(‘+’ ‘o’ ‘*’ ‘.’ ‘x’ ‘s’ ‘d’)
colors(‘k’ ‘r’ ‘g’ ‘b’ ‘m’ ‘c’ ‘w’)

x = lsode ("f", x0, t);
lsode -- Livermore Solver for Ordinary Differential Equations


load x.dat
d = load('data.dat')
t = tmpfile
load t

save mat_ouput.mat matrix;
save mat_ouput.txt v -ascii;
save t v
save variables.lst

print -dpdf foo.pdf



f = figure;
b1 = uicontrol (f, "string", "A Button", "position",[10 10 150 40]);
c1 = uicontrol (f, "style", "checkbox", "string", "a checkbox", "position",[10 120 150 40]);
dims = inputdlg (prompt, "Enter Box Dimensions", rowscols, defaults);
msgbox ("You cancelled.");
gp = uibuttongroup (f, "Position", [ 0 0.5 1 1])
b2 = uicontrol (gp, "style", "radiobutton", "string", "Choice 2", "Position", [ 10 50 100 30 ]);

pkg load symbolic
symbols
y = sym ('y');
expand((x-5)*(x+9))
collect(x^3 *(x-7), z)

octave -qf --no-window-system main.m

Abbreviations:


URLs:
http://satya-data.blogspot.com

